## 학습에 들어가기 앞서

부하 테스트를 진행하는 이유는 시스템 가용성의 범위를 확인하는 목적도 있지만,
테스트를 통해 초당 처리량(Throughput)과 지연시간(Latency Time)을 확인하고   
Application, Database 에서의 병목구간(Bottleneck Point)를 찾아내고   
사전에 대비해 안정된 서비스를 제공하기 위함 입니다.     
병목구간을 찾기 위해서는 자원의 사용량을 객관적으로 판단할 수 있는 지표가 필요 합니다.       
이러한 목적성을 충족하기 위해 부하테스트 툴로 가상의 트래픽을 생성하고 APM을 통해 서버의 처리량과 병목구간을 파악하게 됩니다.

1. **부하 테스트 Tool**
    * TPS(Transfer Per Second) - 초당 처리량
    * Latency(or Duration) Time - 지연시간(응답시간)
2. **성능 모니터링(APM) Tool**
    * CPU Usage - CPU 사용량
    * Memory Usage - 메모리 사용량

**1) 처리량(Throughput)이 중요한 이유?**   
단일 서버로 운영 중인 서비스의 동시 사용자가 1000명이라고 가정하고 모든 요청에 대한 처리 응답은 1초 내에 완료되어야 한다고 했을때,    
서버 1대의 처리 성능이 100 TPS 라면 동시요청은 다음 문제들을 야기할 수 있습니다.

- 시스템 부하
- 처리시간 지연
- 시스템 다운

위 사유 등으로 사용자의 만족도 저하, 서비스 이탈, 신뢰도 하락 등으로 이어져 매출 하락으로 까지 이어질 수 있습니다.    
이러한 이유들이 처리량(Throughput)이 중요한 이유 입니다.

**2) 처리량(Throughput)을 개선 하려면?**   
대규모 트래픽이 발생했을 때 병목구간(Bottleneck Point)을 찾아 처리량을 늘리는 것이 주 목적 입니다.   
병목구간이 발생하는 위치는 크게 WAS 와 Database 로 분류 할 수 있으며, 발생하는 위치에 따라 개선 방법이 다르지만 대표적인 방법으로는 직렬 방식인 `Scale Up`과 병렬 방식인 `Scale Out`
이 있습니다.

- Scale Up
    - 서버의 CPU 및 Memory 등의 스펙을 증설하는 방법 입니다.
    - 다운타임(down time)이 발생 합니다.
- Scale Out
    - 동일한 성능의 서버를 증설하는 방법 입니다. (Load Balancer 또는 클러스터링 필요)
    - 다운타임(down time)이 발생하지 않습니다.

단, 위 내용은 하드웨어를 통한 물리적인 개선 방법으로 병목구간을 파악해 논리적 개선(로직 or Query)을 통한 최적화가 선행 되어야 합니다.

**3) 처리량(Throughput)과 병목 구간을 측정하는 방법?**

- **처리량(Throughput) 확인하기**
    - 동시 요청
- **병목지점(Bottleneck Point) 확인하기**
    - step1. 부하테스트 툴을 이용해 부하를 발생시킵니다.
    - step2. APM을 통해 WAS와 DB의 CPU와 메모리 사용률을 확인 합니다.
    - step3. CPU와 메모리 중 peak에 도달하는 것이 없다면 부하를 늘려 step1 부터 반복 합니다.

**4) 병목지점을 해결해 성능을 해결하는 방법?**

- **WAS 병목구간 해결 방법**
    - `수직 확장(scale up)` - 서버 스펙 향상을 통한 처리량 업그레이드
    - `수평 확장(scale out)` - LoadBalencer를 통한 부하 분산
    - `정적 파일 분리` - CloudFront,S3,CDM 등을 활용한 정적리소스 부하 분산
    - `로직 개선` - 알고리즘을 통해 비효율적인 로직 개선
- **DB 병목구간 해결 방법**
    - `수직 확장(scale up)` - 서버 스펙 향상을 통한 처리량 업그레이드
    - `Read Replica DB` - write와 read 부하 분산
    - `캐시 사용` - 변화가 적고 빈번한 query에 대해 캐시 적용. ex> Redis)
    - `쿼리 개선` - Index, SQL문 튜닝, 역정규화 등을 통한 개선

**4) 가용성(Availability)을 확보 하려면?**    
가용성을 확보하려면 시스템 downtime을 99.9%의 확률로 보장해야 합니다.    
시스템 이중화를 통해

Traffic 규모에 따른 CPU와 Memory 사용량 시각적으로 확인해 병목구간을 찾을 수 있게 됩니다.
병목구간을 개선하는 일반적인 방법 중에서는 Scale Up과 Scale Out이 있을 수 있으며,
대부분의 경우 Scale Out 을 통해 부하를 개선할 수 있습니다.

* Scale Out을 통한 처리량 개선
    * EC2 Instance를 병렬로 구성하고 로드밸런서를 통해 부하를 분산시킬 수 있습니다.
    * 서버 1대가 초당 1000 개의 처리량(Througput) 병렬 구성을 통해 초당 1000 x N 개의 처리량을 가질 수 있습니다.
* Scale Up을 통한 처리량 개선
    * PC의 성능을 높이는 방법으로 downtime이 발생 합니다.
    * Scale Out 과 달리 처리량이 배수로 늘어나지 않습니다.

하지만 병목구간을 해결하면 또 다른 병목구간이 발생한다는 사실도 인지해야 합니다.   
웹 서비스는 보통 `client - was(application) - database` 와 같이 3 tier로 구성 됩니다.    
여기서 Scale Out은 was 에 속하고 application 늘어난 처리량을 database 가 감당하지 못하게 됩니다.   
하지만 RDB의 경우 application과 달리 동기화 문제로 scale out 이 쉽지 않습니다.

이런 경우에 command와 read 를 분리해 database의 부하를 개선하는 방법이 있습니다.

* read replica DB 생성
    * Read Only Replica DB를 생성해 query
    * Master DB가 갱신될떄마다 Replica DB도 갱신하지만 시간차로 동기화 이슈가 있을 수 있습니다.
* NoSQL 사용
    * NoSQL은 조회 성능이 뛰어납니다.
    * Document(json) 형식으로 저장되어 scale out에도 용이 합니다.
    * RDB와 병행 사용 시 동기화에 신경써야 합니다.
* 캐시 사용
    * 변화가 적고 자주 조회되는 데이터에 대해 cache에 저장 합니다.
    * 단일 서버의 경우 EhCache 를 사용해도 무방하지만 이중화를 생각한다면 Redis(or varkey)와 같은 캐시 사용을 권장 합니다.

## 학습에 임하는 자세

1) 효율적인 학습 습관
    - 장기 기억으로 전환할 수 있는 노력이 필요하다.
    - 뇌를 힘들게 할수록 단기 기억에서 장기 기억으로 전환된다.
    - 비효율적인 학습
        1. 단순 영상보기: 두뇌를 사용하지 않아 장기기억으로 넘
    - 효율적인 학습
        1. 어떠한 형태로든 기록 남기기
        2. 내가 이해하기 쉬운 용어로 작성하기
        3. 단순 복사 붙여넣기 형식의 기록은 하지 않기
2) 빠르게 학습하는 방법(**feat. 파레토의 법칙**)
    - 20%만 알아도 80%의 효과를 낼 수 있다.
    - 이론을 많이 알아도 구체화 할 수 없다면 무용지물이다.
    - 현업에서도 자주쓰이는 10% 기능으로 개발이 진행된다.
    - 나머지 부족한 것은 업무를 하면서 익혀가면 된다.
3) 낯선 용어(First Word) 대처하는 하기
    - 새로운 분야를 익힐 때 낯선 용어를 많이 듣게되는데 이로 인해 "어렵다"고 느끼게 된다.
    - 낯선 용어들이 무엇인지 잘 정리해두기만 해도 이해하는데 도움이 된다.
    - 반드시 기록으로 남겨둘 것!(노션, 블로그 기타 등등..)
    - 용어는 내가 이해하기 쉬운 직관적인 의미가 떠오를 수 있도록 정리 하기

## Example  목적

대용량 트래픽은 개발자의 필수 역량 중 하나가 되었습니다.  
하지만 아이러니 하게도 네카라쿠배와 같은 기업에 취업을 하더라도 대부분의 부서에서는 대용량 트래픽이 발생하지 않는 경우가 많다고 합니다.    
그럼에도 대부분의 기업들이 우대사항으로 대용량 트래픽 경험을 원하고 있기에
역량 강화를 위해 부하테스트 툴을 사용해 **대용량 트래픽을 생성해 얼마나 견딜 수 있는지 이후 어떻게 처리할 지에 대한 간접적 경험**을 쌓고자 함에 있습니다.

**현업에서 부하 테스트를 하는 이유?**   
구현된 서비스가 프로덕션 환경에 배포 되었을때 "혹시 요청이 몰려서 서버가 터지면 어떻하지?", "어느 정도의 사용자 요청을 견딜 수 있는거지?" 등과 같이   
시스템 내구성에 대한 불안도가 발생할 수 있습니다.   
이러한 불안을 해소하기 위해 부하테스트 툴을 이용해 임의로 서버에 스트레스(부하)를 발생시켜 내구성과 가용성을 검증하므로 써    
불안을 해소하고 병목구간(bottleleck Point)을 확인해 문제를 해결하는데 목적이 있습니다.

## 핵심 용어

* **처리량(Throughput)**
    * 서비스가 1초당 처리할 수 있는 트래픽 양을 Throughput 이라고 합니다.
    * Ex) 1초에 최대 100개의 API 요청을 처리 할 수 있다면 **100 TPS**라고 합니다.
    * 참고) 현업에서는 "처리량"이라고 하지 않고 Throughput(쓰루풋)이라고 많이 얘기하는 편입니다.
    * 참고) TPS(Transaction Per Seconds) != RPS(Request Per Second) 이지만 같다고 이해하도 무방 합니다.
* **지연 시간(Latency)**
    * 요청에 대한 응답시간을 의미 합니다.
    * 부하 테스트를 진행 했을 떄 평균 응답 시간이 2.5초 일 경우, 평균 Latency가 2.5초라고 얘기 합니다.
    * 조금 더 쉽게 해석하면 API 요청 후 응답받기까지의 시간이 2.5초가 걸린다는 의미로 해석 할 수 있습니다.
* 병목 지점(Bottleneck Point)
    *

## 실습

실습 부하테스트 Tool은 k6를 사용해 진행 합니다.
여러 부하테스트 Tool(jmeter, ngrinder, ab, locust)들이 있지만 사용법이 간단하고 비교적 적은 메모리로 많은 요청 수를 보낼 수 있는 툴 입니다.   
충분한 부하를 생성할 수 있도록 `t3a.small` EC2 을 생성하도록 합니다.

1) API 서버 설치하기
    - [EC에 API 서버 셋팅 - Node.js](../app-traffic-testing/docs/API%20서버%20설치(Node).md)
    - [(준비중) EC에 API 서버 셋팅 - SpringBoot + Java](../app-traffic-testing/docs/API%20서버%20설치(Java).md)

2) 부하 테스트
    - [EC에 부하 테스트 툴 셋팅](../app-traffic-testing/docs/k6%20설치.md)
    - [부하 테스트 시작과 결과 해석](../app-traffic-testing/docs/부하테스트.md)

## 테스트 요약

* 점진적으로 트래픽을 증가시켜 구성한 시스템이 1초당 몇개의 요청을 견딜 수 있는지 알아본다.
* 시스템의 구성과 트래픽을 실제 상황과 유사하게 구사할수록 좋습니다.
*

[Grafana k6 공식문서](https://grafana.com/docs/k6/latest/)


